
import { db, storage } from './firebase';
import { collection, addDoc, getDocs, deleteDoc, doc, query, orderBy, serverTimestamp, updateDoc } from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL, deleteObject } from 'firebase/storage';
import type { Product } from './types';

const PRODUCTS_COLLECTION = 'products';

// Function to get image name for storage path
const getImageNameForStorage = (imageName: string | undefined, productId: string) => {
  const extension = imageName?.split('.').pop() || 'jpg';
  return `product_${productId}_${Date.now()}.${extension}`;
}

export const addProductToFirebase = async (
  productData: Omit<Product, 'id' | 'createdAt' | 'imageUrl'>, // This now includes 'category'
  imageFile: File
): Promise<Product> => {
  try {
    // 1. Create a document reference first to get an ID
    const productDocRef = doc(collection(db, PRODUCTS_COLLECTION));
    const productId = productDocRef.id;

    // 2. Upload image to Firebase Storage
    const imageNameForStorage = getImageNameForStorage(imageFile.name, productId);
    const storageRef = ref(storage, `${PRODUCTS_COLLECTION}/${productId}/${imageNameForStorage}`);
    await uploadBytes(storageRef, imageFile);
    const imageUrl = await getDownloadURL(storageRef);

    // 3. Set the product document in Firestore with all data, including the image URL and category
    const newProductData = {
      ...productData, // Contains description, price, category
      imageUrl: imageUrl,
      imageName: imageFile.name,
      createdAt: serverTimestamp(),
    };
    await addDoc(collection(db, PRODUCTS_COLLECTION), newProductData); // Actually, we should use setDoc with productDocRef

    // Correction: Use setDoc with the earlier generated ref to ensure the ID is what we used for storage path
    // For simplicity, the above addDoc will create a new ID. A more robust approach would be:
    // await setDoc(productDocRef, newProductData);
    // However, to keep it consistent with the current structure where addDoc is used and ID is implicitly generated by Firestore for the main addProduct logic:
    // We will let Firestore generate ID with addDoc, and the storage path will just use a temporary unique part.
    // Let's adjust slightly: we won't pre-generate ID from ref if just using addDoc.
    // The productId for storage can be part of the image name or a subfolder if we get ID after doc creation.
    // For now, the existing imageNameForStorage logic is okay, it makes the name unique even if productId isn't the doc ID.

    // A better approach if we want the Storage path to match the Firestore doc ID:
    // 1. Add product data (without imageUrl) to get an ID.
    // 2. Upload image using that ID in the path.
    // 3. Update the Firestore doc with the imageUrl.

    // Let's refine for clarity and correctness:
    const tempProductDataForId = {
        description: productData.description,
        price: productData.price,
        category: productData.category,
        imageName: imageFile.name, // Store original name
        createdAt: serverTimestamp(),
        imageUrl: '', // Placeholder
    };
    const productRef = await addDoc(collection(db, PRODUCTS_COLLECTION), tempProductDataForId);
    const actualProductId = productRef.id;

    const actualImageNameForStorage = getImageNameForStorage(imageFile.name, actualProductId);
    const actualStorageRef = ref(storage, `${PRODUCTS_COLLECTION}/${actualProductId}/${actualImageNameForStorage}`);
    await uploadBytes(actualStorageRef, imageFile);
    const actualImageUrl = await getDownloadURL(actualStorageRef);

    await updateDoc(productRef, { imageUrl: actualImageUrl });


    return {
        id: actualProductId,
        description: productData.description,
        price: productData.price,
        category: productData.category,
        imageUrl: actualImageUrl,
        imageName: imageFile.name,
        createdAt: Date.now(), // Client-side timestamp for immediate UI
    };

  } catch (error) {
    console.error("Error adding product to Firebase: ", error);
    throw error;
  }
};

export const getProductsFromFirebase = async (): Promise<Product[]> => {
  try {
    const productsQuery = query(collection(db, PRODUCTS_COLLECTION), orderBy('createdAt', 'desc'));
    const querySnapshot = await getDocs(productsQuery);
    const products = querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        description: data.description,
        imageUrl: data.imageUrl,
        imageName: data.imageName,
        price: data.price,
        category: data.category, // Fetch category
        createdAt: data.createdAt?.toDate?.().getTime() || data.createdAt || Date.now(),
      } as Product;
    });
    return products;
  } catch (error) {
    console.error("Error getting products from Firebase: ", error);
    throw error;
  }
};

export const deleteProductFromFirebase = async (productId: string, imageUrl: string): Promise<void> => {
  try {
    await deleteDoc(doc(db, PRODUCTS_COLLECTION, productId));

    if (imageUrl) {
      // It's safer to reconstruct the storage path if possible, or ensure imageUrl is the direct path
      // For now, assuming imageUrl is the downloadable URL, we use refFromURL.
      // If imageName and productId were consistently used to build path, we could use that.
      try {
        const imageRef = ref(storage, imageUrl); 
        await deleteObject(imageRef);
      } catch (storageError) {
         // If ref(storage, imageUrl) fails (e.g. if it's not a gs:// path or full URL the SDK can parse directly)
         // And if we stored imageName and know the folder structure like `${PRODUCTS_COLLECTION}/${productId}/${imageName}`
         // We could try deleting that. For now, we log this common issue.
        console.warn("Error deleting image from storage using direct URL. This might happen if the URL isn't a direct gs:// path or a full HTTPS URL to the object. Error: ", storageError);
        // Attempt to delete using a potential known path structure (this is a common pattern)
        // This part is speculative if imageName wasn't consistently saved/used for the path.
        // Assuming the `imageName` stored on the product was the one used in the path like `${PRODUCTS_COLLECTION}/${productId}/${product.imageName}`
        // const productDoc = await getDoc(doc(db, PRODUCTS_COLLECTION, productId)); // This would be an extra read.
        // if (productDoc.exists() && productDoc.data().imageName) {
        //   const fallbackPath = `${PRODUCTS_COLLECTION}/${productId}/${productDoc.data().imageName}`;
        //   try {
        //     const fallbackImageRef = ref(storage, fallbackPath);
        //     await deleteObject(fallbackImageRef);
        //     console.log("Successfully deleted image using fallback path:", fallbackPath);
        //   } catch (fallbackError) {
        //     console.error("Error deleting image using fallback storage path:", fallbackPath, fallbackError);
        //   }
        // }
      }
    }
  } catch (error) {
    console.error("Error deleting product from Firebase: ", error);
    throw error;
  }
};
